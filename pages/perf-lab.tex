\section{Perf lab}

\subsection{A. What is the difference between spatial and temporal locality}
\textit{Spatial locality} is when we access something in memory then it is likely that we reference some of the nearby addresses some time after. An example is
when we loop through arrays. Then we take the next element each time.
\begin{lstlisting}
void print_items(int a[N]) {

    for(int i = 0; i < N; i++) {
        printf("%d \n", a[i]);
    }
}
\end{lstlisting}
As can be seen above, the loop goes through the elements of array, by accessing it one by one. Here we get elements 
by utilizing how the array structure the data. \textit{Temporal locality} is when an item that is being reference is likely to be 
referenced again in the near future. An example of that is when we create a temporal locality is when we reference a specific variable
at each iteration.
\begin{lstlisting}
int pow(int a, int pow) {
    int tmp = a;

    for(int i = 0; i < pow; i++) {
        tmp = tmp * a;
    }

    return tmp;
}
\end{lstlisting}
When \textit{Spatial} or \textit{temporal locality} the cache is being used. This is very important in terms of performance.
We use the cache to get data that we need for our application fast. The difference between main memory and the L1 cache is around 100 clock cycles.
So by utilizing locality we limit the cache misses and help our applications to utilize the cache better making our applications perform better.

\subsection{B. What is SIMD processing}
SIMD, also known as \textit{Single Instruction Multiple Data}, is a way to perform computations on a lot of data
with one instruction. The way that it works is by defining a vector with the data that we want to perform computations
upon using the \textit{AVX} library. The \textit{AVX} library contains functions that ensures that we perform the computation 
with one single instruction. 

My solution does not utilize SIMD. That is due to not using vectors that we can perform arithmetic operations upon. However, the smooth
solution could have benefitted from it in the cases where we need to take the average of $3 * 3$ pixel. Here we could have created a accumulator vector
and a vector for each row and use the \code{+} between the accumulator and the row. Afterwards we can add each value in the accumulator vector and divide it by nine.
This will lead to removing 3 add instructions in the \code{avg\_smooth} function making it more performant.
