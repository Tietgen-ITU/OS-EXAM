\documentclass[11pt]{article}
\usepackage{xcolor}
\usepackage[T1]{fontenc}
\usepackage{inconsolata}
\usepackage{listings}
\usepackage{graphicx}
\graphicspath{ {./imgs/} }

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage[font={color=codegray},figurename=Figure,labelfont={it}]{caption}

\lstset
{ %Formatting for code in appendix
    language=C,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
}

\newcommand{\code}[1]{{\colorbox{lightgray!15}{\color{orange}\texttt{#1}}}}
\newcommand{\temp}[1]{{\color{red}#1}}
\newcommand{\centeredpic}[3]{
    \begin{figure}[h]
        \includegraphics[scale=0.5]{#1}
        \centering
        \caption{#2}
        \label{fig:#3}
    \end{figure}
}

\title{Operating systems and C - Exam Answers}
\author{Andreas Nicolaj Tietgen - ant@itu.dk}

\begin{document}
\maketitle

\tableofcontents

\section{Data lab}

\subsection{Describe your implementation of \code{howManyBits(x)}}
Sadly I did not make this in time before the hand-in deadline. However, I have figured a way to 
solve the problem. The idea is to perform a binary search for the most significant active bit.
The issue is that we also need to do this for negative numbers where the sign bit is active. In order to 
solve this we then take the bitwise negation of x. Doing so leaves us with a number that is one short of being the
actual absolute value. However, the reason for that is to avoid overflowing to a negative number again. 
When the binary search is finished, we then add 1 to the result in order to take the signed bit into account.

Lets make a walkthrough. We have \code{x = 0xA0FFF0F0} which is a negative number.
We find out that it is a negative number by looking at the signed bit. We then take the
logical negation of the number so that x is now \code{0x5f000f0f}. 
Now what we want to do is to figure out where the most significant active bit is. As mentioned before,
it can be found by performing binary search. 

So we start from the middle:

\centeredpic{howmanybits-01.png}{Bit representation of the negated integer of \code{x}}{hmb-step-1}

We look to the left and check if there is at least 1 bit that is active(i,e, a bit with the value 1). In figure \ref{fig:hmb-step-1}, there is a bit that is active.
For now, we can with confidence say that we at least need 16 bits in order to represent this number.

The following code provides the same result:
\begin{lstlisting}
    int active_bits_left = !!(temp >> 16);
    min_required_bits = active_bits_left << 4;
    
    /* 
/* 
    /* 
    * Shift the result such that we can continue the search for the 
* Shift the result such that we can continue the search for the 
    * Shift the result such that we can continue the search for the 
    * last active bit 
* last active bit 
    * last active bit 
    */
    temp >>= min_required_bits;
    result += min_required_bits; // Store the min required bits
\end{lstlisting}

The \code{!!(temp >> 16)} looks at the left half of the bit representation and returns 1 if there is an active bit and 0 if not. We then bit shift it by 4 in order to get the amount of bits 
that we can guarantee that is required to represent the integer. 

At line 8 we bit shift the \code{min\_required\_bits}, i.e. 16 in this case, such that we can continue our search. The result looks like the following:
\centeredpic{howmanybits-02.png}{The bit representation of temp after bits shifting it. Grey blocks, have been bit shifted out}{hmb-step-2}

As figure \ref{fig:hmb-step-2} shows, we now continue the process of binary search and take the half again. Again we can see that there is
a bit on the left side of line. This guarantee that we now at least need 8 bits on top of the previous 16 bits that we have, i.e. 24.

The code to perform this looks nearly the same as in figure \ref{fig:hmb-step-1}:
\begin{lstlisting}
    int active_bits_left !!(temp >> 8);
    min_required_bits =  active_bits_left << 3;

    /* 
/* 
    /* 
    * Shift the result such that we can continue the search for the 
* Shift the result such that we can continue the search for the 
    * Shift the result such that we can continue the search for the 
    * last active bit 
* last active bit 
    * last active bit 
    */
    temp >>= min_required_bits;
    result += min_required_bits; // Store the min required bits
\end{lstlisting}

The difference is at line 1 and 2. At line 1 we half the amount of bits that we want to bit-shift with at each step until it reaches zero. And at line 2 we decrement the 
amount of bits we bit shift the result of the \code{active\_bits\_left} by one at each step until it reaches zero. 
Another things to notice as well is that we continue to add the minimum required bits that we bit-shift out of the \code{temp} at each step.
The following figure is an illustration of continuing the steps describe: 
\centeredpic{howmanybits-03.png}{An illustration of the continuation of the same steps. The gray blocks have been bit-shited out}{hmb-step-last}

Before the last step of figure \ref{fig:hmb-step-last}, the minimum required bits is 30. The last step is a bit different. The left side of the line does not have an active bit.
For that reason, the variable \code{minimum\_required\_bits} is 0 and we do not bit shift.
The process of performing binary search is done. However we still need to add the result of \code{temp}. Because if the bit on the right side of line is active, then that needs to be added.
Due to our binary search and bit-shifting of the binary representation of the integer, then we only add 1 or 0 to our result. 
Before we return the result, we need to add the sign bit. For that reason we add 1 to the result. We return a result of 32 minimum required bits to represent \code{0xA0FFF0F0}.

\subsection{Describe your implementation of \code{tmin(void)}}
The \code{tmin()} task was about creating the minimum number in a two complement bit representation.
Two's complement uses the most significant bit as a sign bit. That is, the bit at the left most position indicates whether 
it is a negative or positive number. If the bit is 1 then the number is a minus. 

In terms of how the minimum number is represented in a two's complement system then it is by having the first bit set to 1 and then rest of the bits set to 0.
In a 32 bit system then it would look like the following:

\begin{figure}[h]
    $1000 \; 0000 \; 0000 \; 0000 \; 0000 \; 0000 \; 0000 \; 0000_2 = -2147483648_{10}$
    \centering
\end{figure}


Following the set of rules for the assignment, it is solved by having a constant which is \code{0x01}
and then bit-shift by 31 positions like the following:
\begin{lstlisting}
    int tmin() {
        return 0x01 << 31;
    }
\end{lstlisting}


\section{Perf lab}

\subsection{A. What is the difference between spatial and temporal locality}

// TODO: Describe the difference

// TODO: This is mandatory. Provide an example of situations where each is important and explain how caching plays a role

\subsection{B. What is SIMD processing}

// TODO: Explain what SIMD processing is
// TODO: Explain whether or not my solution benefits from SIMD (and if not, why not?)
\section{Malloc lab}
\subsection{Explain in detail your implementation of the \code{mm\_malloc} function}

My implementation of the \code{mm\_malloc()} function stays the same as it was in the book.\temp{(reference the book)}
However, the implementation of the \code{find\_fit()} and \code{place()} has changed, which the \code{mm\_malloc()} use. So in order to explain \code{mm\_malloc()},
the we also have to explain those two functions as well.
The implementation of the malloc lab is the segregated free list. 
The way it is implemented is by first creating an implementation of the implicit free list, then explicit free list, 
which then resulted in the segregated free list.
This means that the segregated free list is basically an explicit free list for each equivalence class.

When implementing the \code{mm\_malloc()} function, it first performs some checks of the requested \code{size}. The first check is to see if the size is equal to 0. If that is the case then we have to return \code{NULL}.
Afterwards, we have to adjust the variable \code{size} to be aligned to 8. There are two cases:
\begin{itemize}
    \item When the requested size is below or equal the constant \code{DSIZE}: We set the adjusted size, i.e. \code{asize}, to $2 * DSIZE$.
    \item When the requested size is above the constant \code{DSIZE}: We use the \code{ALIGN} macro with $size + DSIZE$ as an argument.
\end{itemize}

We add \code{DSIZE} to the actual size in the last case to ensure that we have space for the header and footer.
Now that we have adjusted the size we then try to find a fit in our free list. 
We try to find a fit by using the \code{find\_fit} function.

\subsubsection{find\_fit}
The \code{find\_fit()} utilizes the segregated free list implementation by getting the index to the list that contains the size being requested. 
If the list points to \code{NULL} then we increment the index by 1 and gets the next list. 
If there is not found any fit in any of the lists then \code{find\_fit()} function returns \code{NULL}.
If the list has an entry then due to the first fit implementation, then it will take the first that can hold the requested size.

\subsubsection{place}
\temp{(Add code with line numbers)}

\code{place()} starts by removing the free block, that is going to be allocated, from the free list by using the \code{remove\_from\_free\_list()} function. 
Afterwards it decides whether to split or not. \code{place()} is going to split if the size difference between the free block and the requested size is greater than $2 * DSIZE$.
\temp{Why is it that it needs to be greater than $2 * DSIZE$?}
\code{place()} splits by setting the allocated block to the size of \code{asize}. Afterwards it jumps to the next block with \code{NEXT\_BLKP}.
We then set the header and the footer to be the difference, i.e. the variable \code{size\_diff} and use the \code{insert\_free\_block} to insert the splitted block to the segregated free list.

\subsection{What is pointer arithmetic?}
Pointer arithmetics are a way to move the pointer to another virtual memory address. The special thing to remember is that the amount of bytes 
that the address moves is depending on which type of pointer it is e.g. \code{char}, \code{integer}, \code{long}, and etc.
So as an example in a 64-bit word system, an int32 pointer called \code{int\_p} and a long pointer called \code{long\_p} would move at their own respective data-size.
That means that \code{int\_p+1} would move 4 bytes, whereas the \code{long\_p+1} would move 8 bytes.

That is also why that in malloc lab, in order to move a pointer only 1 byte we then cast the pointer as a char and add one just like: 

\code{HDRP(bp) ((char *)bp - WSIZE)}

\section{Topics from the class}

\subsection{A. What is the difference between traps, faults and aborts in the context of interrupts?}

// TODO: Explain the difference between traps, faults and aborts

\subsection{B. What is the difference between an ephemeral and a well-known port?}
The ephemeral ports are something that is being assigned automatically by kernel of the client. The operating system has a predefined range of ports that it uses to automatically provide a port when a client application wants to communicate through. 
Where as well known ports are typically assigned with some service and has been 
agreed upon by the community. As an example the port 80 is a well known port for the \textit{http} protocol.

\subsection{C. What is a memory leak?}
A memory leak is when something is allocated that is never cleaned up while the application is running. 
It is a lethal thing for an application to occur. This normally happens when we allocate some data in the heap
by using \code{malloc}, from the standard library, and forgets to use the function \code{free} to clean up the memory
at that specific location. \temp{(Create a code example of when a memory leak occurs)}

When you have a memory leak in your application then it indicates that it forgets to clean up.
In order to avoid memory leak then we have to keep track of what we allocated and when we would like to clean it up.
\temp{(TODO: Look if we can do something specific in order to avoid memory leak)}

\subsection{D. What is a race-condition?}
A race condition can happen when two concurrent processes changes the same variable at nearly the same time. 
More specifically this can happen because thread A access the variable \code{int a}. Before the thread begins to add 1 then the operating system performs a thread context switch and then thread B reads the same variable and write \code{a + 1} to it.
However, thread A didn't get that changes since before it gave the control to thread B, happen to read the variable before it could add 1 to it. So for that reason the variable is only added by 1 instead of 2 in this example.

This specific scenario can be very hard to debug. But why? Race conditions does not always occur. So if you were to try debug and recreate the example then another example could occur or it might actually work as expected(in that specific run).

// TODO: Which instructions can you use to avoid a race-condition
We can use the concept of a \textit{mutex} or a \textit{semaphore}. These two provides operations that, if used correctly, can ensure that 
only one thread at a time can access the critical section at a time. 

It is expensive because even though we have a secured the critical section, then all of the threads have to wait until it gets access to
the critical section. They cannot in other words not do any work until it is being let through. This can cause some bottle necks in terms of 
gaining performance if something is taking long time to compute in the critical section.
\end{document}